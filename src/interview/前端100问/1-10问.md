# 1-10问

### :one:写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么:question:
::: details 答案
vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中（建议先了解一下diff算法过程）。<br/>
在交叉对比中，当新节点跟旧节点头尾交叉对比没有结果时，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点（这里对应的是一个key => index 的map映射）。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。<br/>
注：没有绑定key的情况下，并且在遍历模板简单的情况下，会导致虚拟新旧节点对比更快，节点也会复用。而这种复用是就地复用，一种鸭子辩型的复用<br/>
:::
### :two: ['1', '2', '3'].map(parseInt) what & why :question:

::: details 答案
```js
arr.map(function callback(currentValue[, index[, array]]) {
  // Return element for new_array }[, thisArg])
}
```
1. 这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。
2. 而parseInt则是用来解析字符串的，使字符串成为指定基数的整数parseInt(string, radix),接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数
3. 了解这两个函数后，我们可以模拟一下运行情况
  - parseInt('1', 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1。
  - parseInt('2', 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN。
  - parseInt('3', 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN。<br/>
map函数返回的是一个数组，所以最后结果为[1, NaN, NaN]。
:::
### :three: 什么是防抖和节流:question:有什么区别:question:如何实现:question:
::: details 答案
#### 防抖
触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间
```js
function debounce(fn) {
  let timeout = null; // 创建一个标记用来存放定时器的返回值
  return function () {
    clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉
    timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
      fn.apply(this, arguments);
    }, 500);
  };
}
function sayHi() {
  console.log('防抖成功');
}

var inp = document.getElementById('inp');
inp.addEventListener('input', debounce(sayHi)); // 防抖
```


#### 节流
高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率
```js
function throttle(fn) {
  let canRun = true; // 通过闭包保存一个标记
  return function () {
    if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
    canRun = false; // 立即设置为false
    setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
      fn.apply(this, arguments);
      // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
      canRun = true;
    }, 500);
  };
}
function sayHi(e) {
  console.log(e.target.innerWidth, e.target.innerHeight);
}
window.addEventListener('resize', throttle(sayHi));
```
:::



### :four: 介绍下 Set、Map、WeakSet 和 WeakMap 的区别:question:
::: details 答案
  #### 总结
  ##### Set
  1. 成员不能重复
  2. 只有健值，没有健名，有点类似数组。
  3. 可以遍历，方法有add, delete, has
  ##### weakSet
  1. 成员都是对象
  2. 成员都是弱引用，随时可以消失。 可以用来保存DOM节点，不容易造成内存泄漏
  3. 不能遍历，方法有add, delete, has
  ##### Map
  1. 本质上是健值对的集合，类似集合
  2. 可以遍历，方法很多，可以干跟各种数据格式转换
  ##### weakMap
  1. 直接受对象作为健名（null除外），不接受其他类型的值作为健名
  2. 健名所指向的对象，不计入垃圾回收机制
  3. 不能遍历，方法同get,set,has,delete
  #### -------------------------------------------------------------------------------
  #### Set
  它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。
  ```js
  // 例一
  const set = new Set([1, 2, 3, 4, 4]);
  [...set]
  // [1, 2, 3, 4]

  // 例二
  const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
  items.size // 5

  // 例三
  const set = new Set(document.querySelectorAll('div'));
  set.size // 56

  // 类似于
  const set = new Set();
  document
  .querySelectorAll('div')
  .forEach(div => set.add(div));
  set.size // 56

  ```

  #### WeakSet
  WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。
  首先，WeakSet 的成员只能是对象，而不能是其他类型的值。<br>
 
  WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。


  ```js
  const ws = new WeakSet();
  const obj = {};
  const foo = {};

  ws.add(window);
  ws.add(obj);

  ws.has(window); // true
  ws.has(foo);    // false

  ws.delete(window);
  ws.has(window);    // false



  const foos = new WeakSet()
  class Foo {
    constructor() {
      foos.add(this)
    }
    method () {
      if (!foos.has(this)) {
        throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');
      }
    }
  }
  ```

  #### Map
  类似于一个数组，但是成员的值都是唯一的，没有重复的值。
  ```js
  const map = new Map([
    ['name', '张三'],
    ['title', 'Author']
  ]);

  map.size // 2
  map.has('name') // true
  map.get('name') // "张三"
  map.has('title') // true
  map.get('title') // "Author"
  ```

  #### WeakMap
  WeakMap结构与Map结构类似，也是用于生成键值对的集合。
  WeakMap与Map的区别有两点。
  首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。<br/>
  如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap
  ```js
  const map = new WeakMap();
  map.set(1, 2)
  // TypeError: 1 is not an object!
  map.set(Symbol(), 2)
  // TypeError: Invalid value used as weak map key
  map.set(null, 2)
  // TypeError: Invalid value used as weak map key

  const wm = new WeakMap();

  const element = document.getElementById('example');

  wm.set(element, 'some information');
  wm.get(element) // "some information"
  ```
:::

### :five: 介绍下深度优先遍历和广度优先遍历，如何实现:question:
::: details 答案
#### 深度优先遍历DFS 
深度优先遍历DFS 与树的先序遍历比较类似。
假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。
```js
/*深度优先遍历三种方式*/
let deepTraversal1 = (node, nodeList = []) => {
  if (node !== null) {
    nodeList.push(node);
    let children = node.children;
    if (children && children.length) {
      for (let i = 0; i < children.length; i++) {
        deepTraversal1(children[i], nodeList);
      }
    }
  }
  return nodeList;
}
let deepTraversal2 = (node) => {
    let nodes = [];
    if (node !== null) {
      nodes.push(node);
      let children = node.children;
      if (children && children.length) {
        for (let i = 0; i < children.length; i++) {
          nodes = nodes.concat(deepTraversal2(children[i]));
        }
      }
    }
    return nodes;
  }
// 非递归
let deepTraversal3 = (node) => {
  let stack = [];
  let nodes = [];
  if (node) {
    // 推入当前处理的node
    stack.push(node)
    while (stack.length) {
      let item = stack.pop()
      let children = item.children
      nodes.push(item)
      // node = [] stack = [parent]
      // node = [parent] stack = [child3,child2,child1]
      // node = [parent, child1] stack = [child3,child2,child1-2,child1-1]
      // node = [parent, child1-1] stack = [child3,child2,child1-2]
      if (children && children.length) {
        for (let i = children.length - 1; i >= 0; i--) {
          stack.push(children[i])
        }
      }
    }
  }
  return nodes
}
```

#### 广度优先遍历 BFS
从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。 如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。
```js
let widthTraversal2 = (node) => {
  let nodes = []
  let stack = []
  if (node) {
    stack.push(node)
    while (stack.length) {
      let item = stack.shift()
      let children = item.children
      nodes.push(item)
        // 队列，先进先出
        // nodes = [] stack = [parent]
        // nodes = [parent] stack = [child1,child2,child3]
        // nodes = [parent, child1] stack = [child2,child3,child1-1,child1-2]
        // nodes = [parent,child1,child2]
      if (children && children.length) {
        for (let i = 0; i < children.length; i++) {
          stack.push(children[i])
        }
      }
    }
  }
  return nodes
}
```
:::

### :six: 请分别用深度优先思想和广度优先思想实现一个拷贝函数:question:
::: details 答案
:::

### :seven:  :question:
::: details 答案
:::

### :eight:  :question:
::: details 答案
:::

### :nine:  :question:
::: details 答案
:::

### :keycap_ten: 介绍下 Set、Map、WeakSet 和 WeakMap 的区别:question:
::: details 答案
:::

